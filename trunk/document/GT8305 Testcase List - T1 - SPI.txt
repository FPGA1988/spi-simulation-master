#----------------------------------------------GT5238 Testcase List:『SPI』-----------------------------------------------

#_________________________________________________________________________________________________________________________
{ 0 SPI功能概览
0.1 统计：
    testcase总数 = PATRA + PARTB + PARTC = 
{0.2 状态寄存器   Status  Register  : 0x1 0x2 0x3 0x4
    0.2.1 fault标记处于寄存器 0x2的 :
        SNS_A_OCP
        SNS_B_OCP
        SNS_C_OCP
        VDS_LC
        VDS_HC
        VDS_LB
        VDS_HB
        VDS_HA
        VDS_LA
    0.2.2 fault标记处于寄存器 0x3 的 :
        VCPH_OVLO_ABS
        VCPH_OVLO
        VCPH_UVLO
        VCP_LSD_UVLO
        AVDD_UVLO
        VREG_UV
        OTSD
        PVDD_UVLO2
    0.2.3 fault标记处于寄存器 0x4 的 :
        VGS_LC
        VGS_HC
        VGS_HB
        VGS_LB
        VGS_HA
        VGS_LA
    上述的fault类错误都可以用同样的方式来进行设置、清除等
    0.2.4 其他fault类错误
        WATCH_DOG
}
{0.3 控制寄存器   Control Register  : 0x5 0x6 0x7 0x9 0xa 0xb 0xc
    0.3.1 fault的使能/禁止设置处于寄存器0x9的 :
        ___________________________________________________________________
        名称                     位       默认          补充
        DISABLE_OTSD            BIT10    DISABLE        默认禁止此fault，并且其他的0都代表使能，而这里0代表禁止
        DISABLE_PVDD_UVLO2      BIT9     ENABLE
        DISABLE_GRDV_FAULT      BIT8     ENABLE
        DISABLE_SNS_CLAMP       BIT7     ENABLE
        DISABLE_SNS_OCP         BIT4     ENABLE
        DISABLE_SNS_WD          BIT3     DISABLE        默认禁止此fault，并且其他的0都代表使能，而这里0代表禁止
        ___________________________________________________________________
        
        
    0.3.2 fault的使能/禁止设置处于寄存器0xb的 :
        ___________________________________________________________________
        名称                     位       默认          补充
        DISABLE_VREG_PWRGD      BIT10    ENABLE   
        ___________________________________________________________________    
        
    0.3.3 fault的使能/禁止设置处于寄存器0xc的 :    
        #___________________________________________________________________
        名称                     位       默认          补充
        DISABLE_VDS_OCP         BIT2-BIT0 ENABLE        VDS_OCP有三种模式:DISABLE,REPORT和SHUTDOWN，仅当 2:0 = 010 的时候
                                                        处于DISABLE模式
        #___________________________________________________________________   
		#补充@2017.03.28 : 关于VDS OCP的测试，后面需要再详细测试下GT8305芯片的对应功能，目前测试出来和datasheet不一致[没有report only模式]
}    
{0.4 未定义寄存器 Unused  Register  : 0x0 0x8 0xd 0xe 0xf
    0.4.1 warning标记处于寄存器 0x1的 :
		D7	:	PVDD_UVFL
		D6	:	PVDD_OVFL
		D4	:	VCHP_UVFL
		D0	:	OTW
}   
#____________________________________________________END__________________________________________________________________
}

#PART A : 寄存器的基本读写测试
    #注意 ：在disable的开关测试的时候，有以下两点需要特别注意：
	#	1.disable set了之后需要get
	#   2.在有fault产生的情况下disable相应的fault，此时判断寄存器0x1~0x4的值不能再用disable的设置，因为此时的disable不影响fault
#_________________________________________________________________________________________________________________________
{01 测试用例名称 : t1_01 reg 0x1 write and read
1.1 测试要点     : 
	状态寄存器0x1的基本读写功能 : 只读寄存器 default值为全0
1.2 测试步骤     : 
	{
    1.2.1  执行por并等待config done完成
	1.2.2  设置寄存器操作地址为0x1
    1.2.3  读取寄存器并和default值进行比较
	1.2.4  寄存器写0x7ff，写返回时的值应该为default值
	1.2.5  读取寄存器，读出的值应该为default值
	1.2.6  将1.2.4的写的数据分别改为000、555和2aa，无论读还是写寄存器，返回值都应该是default值
	1.2.7  本项测试完成
	}
1.3 测试结果 	 :
	2017-04-13 : 重新验证通过，por之前不能等待时间，否则会造成otp的error和violation
}
{02 测试用例名称 : t1_02 reg 0x2 write and read
2.1 测试要点     : 
	状态寄存器0x2的基本读写功能 : 只读寄存器 default值为全0
2.2 测试步骤     : 
	{
    2.2.1  执行por并等待config done完成
	2.2.2  设置寄存器操作地址为0x2
    2.2.3  读取寄存器并和default值进行比较
	2.2.4  寄存器写0x7ff，写返回时的值应该为default值
	2.2.5  读取寄存器，读出的值应该为default值
	2.2.6  将2.2.4的写的数据分别改为000、555和2aa，无论读还是写寄存器，返回值都应该是default值
	2.2.7  本项测试完成
	}
2.3 测试结果 	 :
	2017-04-13 : 重新验证通过，por之前不能等待时间，否则会造成otp的error和violation
}
{03 测试用例名称 : t1_03 reg 0x3 write and read
3.1 测试要点     : 
	状态寄存器0x3的基本读写功能 : 只读寄存器 default值为全0
3.2 测试步骤     : 
	{
    3.2.1  执行por并等待config done完成
	3.2.2  设置寄存器操作地址为0x3
    3.2.3  读取寄存器并和default值进行比较
	3.2.4  寄存器写0x7ff，写返回时的值应该为default值
	3.2.5  读取寄存器，读出的值应该为default值
	3.2.6  将3.2.4的写的数据分别改为000、555和2aa，无论读还是写寄存器，返回值都应该是default值
	3.2.7  本项测试完成
	}
3.3 测试结果 	 :
	2017-04-13 : 重新验证通过，por之前不能等待时间，否则会造成otp的error和violation
}
{04 测试用例名称 : t1_04 reg 0x4 write and read
4.1 测试要点     : 
	状态寄存器0x4的基本读写功能 : 只读寄存器 default值为全0
4.2 测试步骤     : 
	{
    4.2.1  执行por并等待config done完成
	4.2.2  设置寄存器操作地址为0x4
    4.2.3  读取寄存器并和default值进行比较
	4.2.4  寄存器写0x7ff，写返回时的值应该为default值
	4.2.5  读取寄存器，读出的值应该为default值
	4.2.6  将4.2.4的写的数据分别改为000、555和2aa，无论读还是写寄存器，返回值都应该是default值
	4.2.7  本项测试完成
	}
4.3 测试结果 	 :
	2017-04-13 : 重新验证通过，por之前不能等待时间，否则会造成otp的error和violation
}
{05 测试用例名称 : t1_05 reg 0x5 write and read
5.1 测试要点     : 
	控制寄存器0x5的基本读写功能 : 可读可写寄存器
5.2 测试步骤     : 
	{
    5.2.1  执行por并等待config done完成
	5.2.2  设置寄存器操作地址为0x5
    5.2.3  读取寄存器并和default值进行比较
	5.2.4  开始寄存器的循环读写检测，写的数据从0~0x800
	5.2.5  设置写命令的返回期望以及读命令的返回期望值：
		因为寄存器的最高位为RESERVED，无论写什么读出都为0，因此将期望值&0x3ff
		写命令返回期望 = 寄存器未写之前的值
		读命令返回期望 = 寄存器之前写的值
		因为数据位宽为11位，所以当循环到0x800的时候，读出期望值应该是0
	5.2.6  5.2.5中的循环完成后，重新将寄存器写回default值并校验
	5.2.7  本项测试完成
	}
5.3 测试结果 	 :
	2017-04-13 : 重新验证通过，por之前不能等待时间，否则会造成otp的error和violation
}
{06 测试用例名称 : t1_06 reg 0x6 write and read
6.1 测试要点     : 
	控制寄存器0x6的基本读写功能 : 可读可写寄存器
6.2 测试步骤     : 
	{
    6.2.1  执行por并等待config done完成
	6.2.2  设置寄存器操作地址为0x6
    6.2.3  读取寄存器并和default值进行比较
	6.2.4  开始寄存器的循环读写检测，写的数据从0~0x800
	6.2.5  设置写命令的返回期望以及读命令的返回期望值：
		因为寄存器的最高位为RESERVED，无论写什么读出都为0，因此将期望值&0x3ff
		写命令返回期望 = 寄存器未写之前的值
		读命令返回期望 = 寄存器之前写的值
		因为数据位宽为11位，所以当循环到0x800的时候，读出期望值应该是0
	6.2.6  6.2.5中的循环完成后，重新将寄存器写回default值并校验
	6.2.7  本项测试完成
	}
6.3 测试结果 	 :
	2017-04-13 : 重新验证通过，por之前不能等待时间，否则会造成otp的error和violation
}
{07 测试用例名称 : t1_07 reg 0x7 write and read
7.1 测试要点     : 
	控制寄存器0x7的基本读写功能 : 可读可写寄存器
7.2 测试步骤     : 
	{
    7.2.1  执行por并等待config done完成
	7.2.2  设置寄存器操作地址为0x7
    7.2.3  读取寄存器并和default值进行比较
	7.2.4  开始寄存器的循环读写检测，写的数据从0~0x800
	7.2.5  设置写命令的返回期望以及读命令的返回期望值：
		因为寄存器的最高位为RESERVED，无论写什么读出都为0，因此将期望值&0x3ff
		写命令返回期望 = 寄存器未写之前的值
		读命令返回期望 = 寄存器之前写的值
		因为数据位宽为11位，所以当循环到0x800的时候，读出期望值应该是0
		#注意 ： 因为写寄存器0x7会更改PWM模式，因此需要关闭gate driver的检测，避免gate driver报错
	7.2.6  7.2.5中的循环完成后，重新将寄存器写回default值并校验
	7.2.7  本项测试完成
	}
7.3 测试结果 	 :
	2017-04-13 : 在测试过程中发现Q1版本的0x7的D10是使用了，之前的版本是RESERVED，经过商议，我们的设计也不需要这一位
}
{08 测试用例名称 : t1_08 reg 0x9 write and read
8.1 测试要点     : 
	控制寄存器0x9的基本读写功能 : 可读可写寄存器
8.2 测试步骤     : 
	{
    8.2.1  执行por并等待config done完成
	8.2.2  设置寄存器操作地址为0x7
    8.2.3  读取寄存器并和default值进行比较
	8.2.4  开始寄存器的循环读写检测，写的数据从0~0x800
	8.2.5  设置写命令的返回期望以及读命令的返回期望值：
		因为寄存器的最高位为RESERVED，无论写什么读出都为0，因此将期望值&0x3ff
		写命令返回期望 = 寄存器未写之前的值
		读命令返回期望 = 寄存器之前写的值
		因为数据位宽为11位，所以当循环到0x800的时候，读出期望值应该是0
		#注意 ： 
			#A.因为写寄存器0x9可能会影响watch dog和sleep，因此这两位都不进行写操作，寄存器的测试放在
			#watch dog和sleep的测试中。
			#B.clr flt会自清0的操作也在其他case中进行测试
	8.2.6  8.2.5中的循环完成后，重新将寄存器写回default值并校验
	8.2.7  本项测试完成
	}
8.3 测试结果 	 :
	2017-04-13 : 除了'注意'中的A&B两点没有测试外，其他值的读写测试均通过
}
{09 测试用例名称 : t1_09 reg 0xa write and read
9.1 测试要点     : 
	控制寄存器0xa的基本读写功能 : 可读可写寄存器
	#注意，本寄存器所有位均可读写
9.2 测试步骤     : 
	{
    9.2.1  执行por并等待config done完成
	9.2.2  设置寄存器操作地址为0xa
    9.2.3  读取寄存器并和default值进行比较
	9.2.4  开始寄存器的循环读写检测，写的数据从0~0x800
	9.2.5  设置写命令的返回期望以及读命令的返回期望值：
		写命令返回期望 = 寄存器未写之前的值
		读命令返回期望 = 寄存器之前写的值
		因为数据位宽为11位，所以当循环到0x800的时候，读出期望值应该是0
	9.2.6  9.2.5中的循环完成后，重新将寄存器写回default值并校验
	9.2.7  本项测试完成
	}
9.3 测试结果 	 :
	2017-04-13 : 重新验证通过，por之前不能等待时间，否则会造成otp的error和violation
}
{10 测试用例名称 : t1_10 reg 0xb write and read
10.1 测试要点     : 
	控制寄存器0xb的基本读写功能 : 可读可写寄存器
	#注意，本寄存器有几位是reserved，写任何值读出来的值都为0，需要特殊处理
10.2 测试步骤     : 
	{
    10.2.1  执行por并等待config done完成
	10.2.2  设置寄存器操作地址为0xb
    10.2.3  读取寄存器并和default值进行比较
	10.2.4  开始寄存器的循环读写检测，写的数据从0~0x800
	10.2.5  设置写命令的返回期望以及读命令的返回期望值：
		写命令返回期望 = 寄存器未写之前的值
		读命令返回期望 = 寄存器之前写的值
		因为数据位宽为11位，所以当循环到0x800的时候，读出期望值应该是0
	10.2.6  10.2.5中的循环完成后，重新将寄存器写回default值并校验
	10.2.7  本项测试完成
	}
10.3 测试结果 	 :
	2017-04-13 : 重新验证通过，por之前不能等待时间，否则会造成otp的error和violation
}
{11 测试用例名称 : t1_11 reg 0xc write and read
11.1 测试要点     : 
	控制寄存器0xc的基本读写功能 : 可读可写寄存器
	#注意，本寄存器有几位是reserved，写任何值读出来的值都为0，需要特殊处理
11.2 测试步骤     : 
	{
    11.2.1  执行por并等待config done完成
	11.2.2  设置寄存器操作地址为0xc
    11.2.3  读取寄存器并和default值进行比较
	11.2.4  开始寄存器的循环读写检测，写的数据从0~0x800
	11.2.5  设置写命令的返回期望以及读命令的返回期望值：
		写命令返回期望 = 寄存器未写之前的值
		读命令返回期望 = 寄存器之前写的值
		因为数据位宽为11位，所以当循环到0x800的时候，读出期望值应该是0
	11.2.6  11.2.5中的循环完成后，重新将寄存器写回default值并校验
	11.2.7  本项测试完成
	}
11.3 测试结果 	 :
	2017-04-13 : 重新验证通过，por之前不能等待时间，否则会造成otp的error和violation
}

{12 测试用例名称 : t1_12 reg 0x0 0x8 0xd 0xe 0xf write and read
12.1 测试要点     : 
	寄存器0x0 0x8 0xd 0xe 0xf在normal模式下的读写，读出来的
	#注意，这些寄存器的读出期望值为全0
12.2 测试步骤     : 
	{
    12.2.1  执行por并等待config done完成
	12.2.2  设置寄存器操作地址为0x0
    12.2.3  读取寄存器并和0值进行比较
	12.2.4  开始寄存器的循环读写检测，写的数据从0~0x800
	12.2.5  设置写命令的返回期望以及读命令的返回期望值：
		写命令返回期望 = 0
		读命令返回期望 = 0
		因为数据位宽为11位，所以当循环到0x800的时候，读出期望值应该是0
	12.2.6  12.2.5中的循环完成后，重新将寄存器写回default值并校验
	12.2.7  本项测试完成
	}
12.3 测试结果 	 :
	2017-04-13 : 基本测试通过，不过在测试中出现了错误的进入测试模式的问题，后续需要关注下测试模式的进入
}


{13.1 测试要点     : 
    测试watch dog的基本功能 : 设置不同的watch dog delay对watch dog的fault进入时间有不同的影响
	#期间有一个随机的从watch dog fault生效到清除的一个随机事件，这个随机时间可以看到当小于56us时，pwrgd是否保持56us
	#测试在watch dog delay时间内连续读地址0x1，则不会watch dog fault生效，一旦停止，则会watch dog生效
	#测试当watch生效后，读0x1不会再清除watch dog fault
	#测试watch dog的delay随机
13.2 测试步骤     : 
	{
	13.2.1  执行por，并检查所有寄存器的初始值
	13.2.2  拉高en_gate，然后设置一些初始值
	13.2.3  设置watch dog delay的值，delay值的顺序随机生成，并同时使能watch dog
	13.2.4  在watch dog delay时间没到之前，gate driver都是打开的，这个时候读寄存器0x1，则watch dog一直不会生效，总共执行30个watch dog delay时间
	13.2.5  在13.2.4开始执行的时候同时开始gate driver的检测，并且一直检测nfault和pwrgd都不会拉低
	13.2.6  前面连续读0x1 30个watch dog delay时间后，关闭gate driver的检测，因为接下来gate driver可能会在某个时间关闭，很难提前判断gate driver会关闭，
	        因此提前关闭检测，关闭pwrgd的检测
	13.2.7  等nfault拉低，然后开始gate driver的关闭检测，同时开始检测pwrgd信号[拉低56us]
	13.2.8  读几次寄存器0x1，并不需要判断值，直接13.2.7中的检测有没有受影响即可
	13.2.9  使用clear fault来清除watch dog产生的fault
	13.2.10 检查一下gate driver是否打开，nfault是否拉高，pwrgd是否为高
	13.2.11 停止gate driver的输入
	13.2.12 重新随机选择watch dog delay，然后执行13.2.3~13.2.11 执行次数为32次
	13.2.13 本项测试完成
	}
13.3 测试结果
	2017-03-28 : 暂时将pwm的最小占空比调到了1，后面再解决这个问题，除了这个问题外本case pass
}

#
#____________________________________________________END__________________________________________________________________


#PART B : Option fault测试
{20 测试用例名称 : t1_20 
20.1 测试要点     : 
	测试0.4中提到的4个warning的基本特性[状态寄存器的清除]，warning源随机生成，然后同时拉低
	#后续还会测试其他清除方式，这些清除方式是在芯片手册上没有提到的
20.2 测试步骤     : 
	{
    20.2.1  执行芯片POR，将所有的错误输入设置为无效值[0]
    20.2.2  执行寄存器的默认值读检测，保证寄存器处于default状态
	20.2.3  随机生成warning源，约束warning源!=0，保证每个值能随机到
	20.2.4  开启nfault toggle检测以及gate driver的检测，gate driver不会关闭，并等待50ms
	20.2.5  验证两次write 0x1不会清除warning，验证读写两次0x2~0x4都不会清除warning
	20.2.6  等待50ms的测试时间，接下来准备用读0x1来清除warning，所以先要把nfault的检查进程停止
	20.2.7	读取寄存器0x1，寄存器的值保持有错误的标记，nfault会在一定时间后拉高
	20.2.8	等待10ms再次读取寄存器0x1，错误标记保持
	20.2.9  去掉所有的warning源
	20.2.10 再次验证12.2.5中的操作不会清除warning，然后等待100us
	20.2.11 读0x1，读出的值应该是有warning
	20.2.12	读出的值应该是没有任何warning，错误已经被20.2.11中的读清除
	20.2.13 再次读0x1，读出的值应该是没有任何warning，错误已经被20.2.11中的读清除
	20.2.14 fault拉高检测禁止，等待tDLY时间
	20.2.15 循环执行20.2.3~20.2.14，循环次数总共16次
	}
}
{21 测试用例名称 : t1_21 
21.1 测试要点     : 
	测试0.4中提到的4个warning的基本特性[在warning源还在的时候不清除warning，在撤销之后再清除]，warning源随机生成，然后同时拉低
	#后续还会测试其他清除方式，这些清除方式是在芯片手册上没有提到的
21.2 测试步骤     : 
	{
    21.2.1  执行芯片POR，将所有的错误输入设置为无效值[0]
    21.2.2  执行寄存器的默认值读检测，保证寄存器处于default状态
	21.2.3  随机生成warning源，约束warning源!=0，保证每个值能随机到
	21.2.4  开启nfault toggle检测以及gate driver的检测，gate driver不会关闭，并等待50ms
	21.2.5  验证两次write 0x1不会清除warning，验证读写两次0x2~0x4都不会清除warning
	21.2.6  去掉所有的warning源
	21.2.7  验证写0x1两次，读写0x2~0x4的操作不会清除warning，然后等待100us
	21.2.8  停止nfault的检测，然后读0x1
	21.2.9	读出的值应该有warning
	21.2.10 等待tDLY时间，然后开始nfault的拉高检测
	21.2.11 再次写寄存器0x1，读出的值应该是没有任何warning，错误已经被21.2.8中的读清除
	21.2.12 读寄存器0x1，应该没有错误。最后fault拉高检测禁止，等待tDLY时间
	21.2.13 循环执行21.2.3~21.2.12，循环次数总共16次
	}
}
{22 测试用例名称 : t1_22 
22.1 测试要点     : 
	测试0.4中提到的4个warning的在datasheet中没有提到的清除方式[clr_flt]，warning源随机生成，然后同时拉低
	#1.验证clr_flt对warning的清除效果一模一样
	#2.本次主要验证在warning错误源还在的情况下的清除以及warning已经撤销的情况下清除
22.2 测试步骤     : 
	{
    22.2.1  执行芯片POR，将所有的错误输入设置为无效值[0]
    22.2.2  执行寄存器的默认值读检测，保证寄存器处于default状态
	22.2.3  随机生成warning源，约束warning源!=0，保证每个值能随机到
	22.2.4  开启nfault toggle检测以及gate driver的检测，gate driver不会关闭，并等待50ms
	22.2.5  写寄存器0x1看是否有错误标记
	#注意 ： 以下两点不在本case中进行测试，而在spi的case中作为异常帧的测试
	#22.2.6	写寄存器0x9，但是CLT_FLT以及WATCH_DOG使能位一直保持0，将所有数据循环完成，证明写其他数据不能清除错误
	#22.2.7  读寄存器0x9，验证读0x9不会清除错误
	22.2.6  停止nfault的检测，因为接下来一旦发送clr_flt，就会清除掉nfault
	22.2.7  发出clr_flt，等待tDLY之后，开始检查nfault的拉高状态
	22.2.8  写0x1，读0x9，再次写0x9，都不会对warning标记造成影响[不能清除掉warning标记]，测试50ms
	22.2.7  撤销warning源，然后等待tDLY
	22.2.8  两次写寄存器0x1，应该都包含错误标记
	22.2.9  写寄存器0x9，这个时候会清除掉warning标记，等待tDLY
	22.2.10 写寄存器0x1，发现warning的错误标记被完全清楚
	22.2.11 等待5ms，停止gate driver的检测，准备下一循环测试
	22.2.12 将clr flt的发送设置在warning条件撤销之后，再warning源还在的情况下不发送clr_flt
	22.2.13	在22.2.12发送clr_flt会直接清除nfault和warning标记，然后直接写0x1会读到全0值
	22.2.14 重复执行22.2.3~22.2.13，随机测试所有的warning
	22.2.15 本项测试完成
	}
22.3 测试结果
	2017-03-28 : 测试Pass
}
{23 测试用例名称 : t1_23 
23.1 测试要点     : 
	测试0.4中提到的4个warning的在datasheet中没有提到的清除方式[en_gate]，warning源随机生成，然后同时拉低
	#1.验证en_gate对warning的清除效果一模一样
	#2.本次主要验证在warning错误源已经撤销的情况下的清除以及warning已经撤销的情况下清除
23.2 测试步骤     : 
	{
    22.2.1  执行芯片POR，将所有的错误输入设置为无效值[0]
    22.2.2  执行寄存器的默认值读检测，保证寄存器处于default状态
	22.2.3  随机生成warning源，约束warning源!=0，保证每个值能随机到
	22.2.4  开启nfault toggle检测以及gate driver的检测，gate driver不会关闭，并等待50ms
	22.2.5  写寄存器0x1看是否有错误标记
	#注意 ： 以下两点不在本case中进行测试，而在spi的case中作为异常帧的测试
	#22.2.6	写寄存器0x9，但是CLT_FLT以及WATCH_DOG使能位一直保持0，将所有数据循环完成，证明写其他数据不能清除错误
	#22.2.7  读寄存器0x9，验证读0x9不会清除错误
	22.2.6  停止nfault的检测，因为接下来一旦发送en_gate低脉冲，就会清除掉nfault
	22.2.7  发出en_gate低脉冲，等待tDLY之后，开始检查nfault的拉高状态
	22.2.8  写0x1，读0x9，再次写0x9，都不会对warning标记造成影响[不能清除掉warning标记]，测试50ms
	22.2.7  撤销warning源，然后等待tDLY
	22.2.8  两次写寄存器0x1，应该都包含错误标记
	22.2.9  写寄存器0x9，这个时候会清除掉warning标记，等待tDLY
	22.2.10 写寄存器0x1，发现warning的错误标记被完全清楚
	22.2.11 等待5ms，停止gate driver的检测，准备下一循环测试
	22.2.12 将en_gate低脉冲的发送设置在warning条件撤销之后，再warning源还在的情况下不发送en_gate低脉冲
	22.2.13	在22.2.12发送clr_flt会直接清除nfault和warning标记，然后直接写0x1会读到全0值
	22.2.14 重复执行22.2.3~22.2.13，随机测试所有的warning
	#注意 ： 在以上测试中，发送en_gate的时候会临时关闭gate driver，所以这段时间需要跳过
	22.2.15 本项测试完成
	}
23.3 测试结果
	2017-03-28 : 今天测试结果为en_gate在源未撤销的时候会拉高nfault，但是en_gate这个脉冲消失后，nfault又会重新toggle
}

#PART C : 其他测试 - t1_30 ~ t1_xx


#下面是测试记录等附加信息
{99	测试记录 : 用于基本的测试记录管理
99.1 未测试Feature记录
	{
	99.1.1 vds ocp的因为还需要进行进一步的仔细测试，所以还没有进行tesecase的编写，主要是经过芯片测试出来没有report only模式
	99.1.2 

	}	
	
99.2 测试出的问题记录	
	{
	#注意 ：
	#	每一个question都有一个对应的answer，是测试现象以及一些对应的解决方案等，如果没有解决或者解释，则用xxx表示	
	2017.03.29 
		Q1 : unpowered system模式的特点？
		A1 : 能读写寄存器，但是寄存器不能生效?至少就sleep而言，在unpowered下并不能进入sleep，还需要仔细测试下watch dog
		A2 : 测试出在unpowered system使能watch dog可以生效，而不能进入sleep模式
		#----#
		Q2 : 设置sleep delay为0，进sleep模式，需要至少拉低wake 9us，退出sleep，也需要拉高至少wake 9us，因此，进入退出一次sleep，
		至少有20us左右
	2017.03.30
		Q1 : 
		A1 :
		
		Q2 :
		A2 :
	}	
99.3 	
	
	



}


#--------------------------------------------------------------------------------------------------------------------------